{"version":3,"file":"js/vendors~application~application_old~google_analytics-ca5c299620451dafe6df.chunk.js","sources":["webpack:///./node_modules/jquery-lazy/jquery.lazy.js"],"sourcesContent":["/*!\r\n * jQuery & Zepto Lazy - v1.7.10\r\n * http://jquery.eisbehr.de/lazy/\r\n *\r\n * Copyright 2012 - 2018, Daniel 'Eisbehr' Kern\r\n *\r\n * Dual licensed under the MIT and GPL-2.0 licenses:\r\n * http://www.opensource.org/licenses/mit-license.php\r\n * http://www.gnu.org/licenses/gpl-2.0.html\r\n *\r\n * $(\"img.lazy\").lazy();\r\n */\n;\n\n(function (window, undefined) {\n  \"use strict\"; // noinspection JSUnresolvedVariable\n\n  /**\r\n   * library instance - here and not in construct to be shorter in minimization\r\n   * @return void\r\n   */\n\n  var $ = window.jQuery || window.Zepto,\n\n  /**\r\n   * unique plugin instance id counter\r\n   * @type {number}\r\n   */\n  lazyInstanceId = 0,\n\n  /**\r\n   * helper to register window load for jQuery 3\r\n   * @type {boolean}\r\n   */\n  windowLoaded = false;\n  /**\r\n   * make lazy available to jquery - and make it a bit more case-insensitive :)\r\n   * @access public\r\n   * @type {function}\r\n   * @param {object} settings\r\n   * @return {LazyPlugin}\r\n   */\n\n  $.fn.Lazy = $.fn.lazy = function (settings) {\n    return new LazyPlugin(this, settings);\n  };\n  /**\r\n   * helper to add plugins to lazy prototype configuration\r\n   * @access public\r\n   * @type {function}\r\n   * @param {string|Array} names\r\n   * @param {string|Array|function} [elements]\r\n   * @param {function} loader\r\n   * @return void\r\n   */\n\n\n  $.Lazy = $.lazy = function (names, elements, loader) {\n    // make second parameter optional\n    if ($.isFunction(elements)) {\n      loader = elements;\n      elements = [];\n    } // exit here if parameter is not a callable function\n\n\n    if (!$.isFunction(loader)) {\n      return;\n    } // make parameters an array of names to be sure\n\n\n    names = $.isArray(names) ? names : [names];\n    elements = $.isArray(elements) ? elements : [elements];\n    var config = LazyPlugin.prototype.config,\n        forced = config._f || (config._f = {}); // add the loader plugin for every name\n\n    for (var i = 0, l = names.length; i < l; i++) {\n      if (config[names[i]] === undefined || $.isFunction(config[names[i]])) {\n        config[names[i]] = loader;\n      }\n    } // add forced elements loader\n\n\n    for (var c = 0, a = elements.length; c < a; c++) {\n      forced[elements[c]] = names[0];\n    }\n  };\n  /**\r\n   * contains all logic and the whole element handling\r\n   * is packed in a private function outside class to reduce memory usage, because it will not be created on every plugin instance\r\n   * @access private\r\n   * @type {function}\r\n   * @param {LazyPlugin} instance\r\n   * @param {object} config\r\n   * @param {object|Array} items\r\n   * @param {object} events\r\n   * @param {string} namespace\r\n   * @return void\r\n   */\n\n\n  function _executeLazy(instance, config, items, events, namespace) {\n    /**\r\n     * a helper to trigger the 'onFinishedAll' callback after all other events\r\n     * @access private\r\n     * @type {number}\r\n     */\n    var _awaitingAfterLoad = 0,\n\n    /**\r\n     * visible content width\r\n     * @access private\r\n     * @type {number}\r\n     */\n    _actualWidth = -1,\n\n    /**\r\n     * visible content height\r\n     * @access private\r\n     * @type {number}\r\n     */\n    _actualHeight = -1,\n\n    /**\r\n     * determine possibly detected high pixel density\r\n     * @access private\r\n     * @type {boolean}\r\n     */\n    _isRetinaDisplay = false,\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _afterLoad = 'afterLoad',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _load = 'load',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _error = 'error',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _img = 'img',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _src = 'src',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _srcset = 'srcset',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _sizes = 'sizes',\n\n    /**\r\n     * dictionary entry for better minimization\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _backgroundImage = 'background-image';\n    /**\r\n     * initialize plugin\r\n     * bind loading to events or set delay time to load all items at once\r\n     * @access private\r\n     * @return void\r\n     */\n\n\n    function _initialize() {\n      // detect actual device pixel ratio\n      // noinspection JSUnresolvedVariable\n      _isRetinaDisplay = window.devicePixelRatio > 1; // prepare all initial items\n\n      items = _prepareItems(items); // if delay time is set load all items at once after delay time\n\n      if (config.delay >= 0) {\n        setTimeout(function () {\n          _lazyLoadItems(true);\n        }, config.delay);\n      } // if no delay is set or combine usage is active bind events\n\n\n      if (config.delay < 0 || config.combined) {\n        // create unique event function\n        events.e = _throttle(config.throttle, function (event) {\n          // reset detected window size on resize event\n          if (event.type === 'resize') {\n            _actualWidth = _actualHeight = -1;\n          } // execute 'lazy magic'\n\n\n          _lazyLoadItems(event.all);\n        }); // create function to add new items to instance\n\n        events.a = function (additionalItems) {\n          additionalItems = _prepareItems(additionalItems);\n          items.push.apply(items, additionalItems);\n        }; // create function to get all instance items left\n\n\n        events.g = function () {\n          // filter loaded items before return in case internal filter was not running until now\n          return items = $(items).filter(function () {\n            return !$(this).data(config.loadedName);\n          });\n        }; // create function to force loading elements\n\n\n        events.f = function (forcedItems) {\n          for (var i = 0; i < forcedItems.length; i++) {\n            // only handle item if available in current instance\n            // use a compare function, because Zepto can't handle object parameter for filter\n            // var item = items.filter(forcedItems[i]);\n\n            /* jshint loopfunc: true */\n            var item = items.filter(function () {\n              return this === forcedItems[i];\n            });\n\n            if (item.length) {\n              _lazyLoadItems(false, item);\n            }\n          }\n        }; // load initial items\n\n\n        _lazyLoadItems(); // bind lazy load functions to scroll and resize event\n        // noinspection JSUnresolvedVariable\n\n\n        $(config.appendScroll).on('scroll.' + namespace + ' resize.' + namespace, events.e);\n      }\n    }\n    /**\r\n     * prepare items before handle them\r\n     * @access private\r\n     * @param {Array|object|jQuery} items\r\n     * @return {Array|object|jQuery}\r\n     */\n\n\n    function _prepareItems(items) {\n      // fetch used configurations before loops\n      var defaultImage = config.defaultImage,\n          placeholder = config.placeholder,\n          imageBase = config.imageBase,\n          srcsetAttribute = config.srcsetAttribute,\n          loaderAttribute = config.loaderAttribute,\n          forcedTags = config._f || {}; // filter items and only add those who not handled yet and got needed attributes available\n\n      items = $(items).filter(function () {\n        var element = $(this),\n            tag = _getElementTagName(this);\n\n        return !element.data(config.handledName) && (element.attr(config.attribute) || element.attr(srcsetAttribute) || element.attr(loaderAttribute) || forcedTags[tag] !== undefined);\n      }) // append plugin instance to all elements\n      .data('plugin_' + config.name, instance);\n\n      for (var i = 0, l = items.length; i < l; i++) {\n        var element = $(items[i]),\n            tag = _getElementTagName(items[i]),\n            elementImageBase = element.attr(config.imageBaseAttribute) || imageBase; // generate and update source set if an image base is set\n\n\n        if (tag === _img && elementImageBase && element.attr(srcsetAttribute)) {\n          element.attr(srcsetAttribute, _getCorrectedSrcSet(element.attr(srcsetAttribute), elementImageBase));\n        } // add loader to forced element types\n\n\n        if (forcedTags[tag] !== undefined && !element.attr(loaderAttribute)) {\n          element.attr(loaderAttribute, forcedTags[tag]);\n        } // set default image on every element without source\n\n\n        if (tag === _img && defaultImage && !element.attr(_src)) {\n          element.attr(_src, defaultImage);\n        } // set placeholder on every element without background image\n        else if (tag !== _img && placeholder && (!element.css(_backgroundImage) || element.css(_backgroundImage) === 'none')) {\n            element.css(_backgroundImage, \"url('\" + placeholder + \"')\");\n          }\n      }\n\n      return items;\n    }\n    /**\r\n     * the 'lazy magic' - check all items\r\n     * @access private\r\n     * @param {boolean} [allItems]\r\n     * @param {object} [forced]\r\n     * @return void\r\n     */\n\n\n    function _lazyLoadItems(allItems, forced) {\n      // skip if no items where left\n      if (!items.length) {\n        // destroy instance if option is enabled\n        if (config.autoDestroy) {\n          // noinspection JSUnresolvedFunction\n          instance.destroy();\n        }\n\n        return;\n      }\n\n      var elements = forced || items,\n          loadTriggered = false,\n          imageBase = config.imageBase || '',\n          srcsetAttribute = config.srcsetAttribute,\n          handledName = config.handledName; // loop all available items\n\n      for (var i = 0; i < elements.length; i++) {\n        // item is at least in loadable area\n        if (allItems || forced || _isInLoadableArea(elements[i])) {\n          var element = $(elements[i]),\n              tag = _getElementTagName(elements[i]),\n              attribute = element.attr(config.attribute),\n              elementImageBase = element.attr(config.imageBaseAttribute) || imageBase,\n              customLoader = element.attr(config.loaderAttribute); // is not already handled \n\n\n          if (!element.data(handledName) && ( // and is visible or visibility doesn't matter\n          !config.visibleOnly || element.is(':visible')) && ( // and image source or source set attribute is available\n          (attribute || element.attr(srcsetAttribute)) && ( // and is image tag where attribute is not equal source or source set\n          tag === _img && (elementImageBase + attribute !== element.attr(_src) || element.attr(srcsetAttribute) !== element.attr(_srcset)) || // or is non image tag where attribute is not equal background\n          tag !== _img && elementImageBase + attribute !== element.css(_backgroundImage)) || // or custom loader is available\n          customLoader)) {\n            // mark element always as handled as this point to prevent double handling\n            loadTriggered = true;\n            element.data(handledName, true); // load item\n\n            _handleItem(element, tag, elementImageBase, customLoader);\n          }\n        }\n      } // when something was loaded remove them from remaining items\n\n\n      if (loadTriggered) {\n        items = $(items).filter(function () {\n          return !$(this).data(handledName);\n        });\n      }\n    }\n    /**\r\n     * load the given element the lazy way\r\n     * @access private\r\n     * @param {object} element\r\n     * @param {string} tag\r\n     * @param {string} imageBase\r\n     * @param {function} [customLoader]\r\n     * @return void\r\n     */\n\n\n    function _handleItem(element, tag, imageBase, customLoader) {\n      // increment count of items waiting for after load\n      ++_awaitingAfterLoad; // extended error callback for correct 'onFinishedAll' handling\n\n      var _errorCallback = function errorCallback() {\n        _triggerCallback('onError', element);\n\n        _reduceAwaiting(); // prevent further callback calls\n\n\n        _errorCallback = $.noop;\n      }; // trigger function before loading image\n\n\n      _triggerCallback('beforeLoad', element); // fetch all double used data here for better code minimization\n\n\n      var srcAttribute = config.attribute,\n          srcsetAttribute = config.srcsetAttribute,\n          sizesAttribute = config.sizesAttribute,\n          retinaAttribute = config.retinaAttribute,\n          removeAttribute = config.removeAttribute,\n          loadedName = config.loadedName,\n          elementRetina = element.attr(retinaAttribute); // handle custom loader\n\n      if (customLoader) {\n        // on load callback\n        var _loadCallback = function loadCallback() {\n          // remove attribute from element\n          if (removeAttribute) {\n            element.removeAttr(config.loaderAttribute);\n          } // mark element as loaded\n\n\n          element.data(loadedName, true); // call after load event\n\n          _triggerCallback(_afterLoad, element); // remove item from waiting queue and possibly trigger finished event\n          // it's needed to be asynchronous to run after filter was in _lazyLoadItems\n\n\n          setTimeout(_reduceAwaiting, 1); // prevent further callback calls\n\n          _loadCallback = $.noop;\n        }; // bind error event to trigger callback and reduce waiting amount\n\n\n        element.off(_error).one(_error, _errorCallback) // bind after load callback to element\n        .one(_load, _loadCallback); // trigger custom loader and handle response\n\n        if (!_triggerCallback(customLoader, element, function (response) {\n          if (response) {\n            element.off(_load);\n\n            _loadCallback();\n          } else {\n            element.off(_error);\n\n            _errorCallback();\n          }\n        })) {\n          element.trigger(_error);\n        }\n      } // handle images\n      else {\n          // create image object\n          var imageObj = $(new Image()); // bind error event to trigger callback and reduce waiting amount\n\n          imageObj.one(_error, _errorCallback) // bind after load callback to image\n          .one(_load, function () {\n            // remove element from view\n            element.hide(); // set image back to element\n            // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'\n\n            if (tag === _img) {\n              element.attr(_sizes, imageObj.attr(_sizes)).attr(_srcset, imageObj.attr(_srcset)).attr(_src, imageObj.attr(_src));\n            } else {\n              element.css(_backgroundImage, \"url('\" + imageObj.attr(_src) + \"')\");\n            } // bring it back with some effect!\n\n\n            element[config.effect](config.effectTime); // remove attribute from element\n\n            if (removeAttribute) {\n              element.removeAttr(srcAttribute + ' ' + srcsetAttribute + ' ' + retinaAttribute + ' ' + config.imageBaseAttribute); // only remove 'sizes' attribute, if it was a custom one\n\n              if (sizesAttribute !== _sizes) {\n                element.removeAttr(sizesAttribute);\n              }\n            } // mark element as loaded\n\n\n            element.data(loadedName, true); // call after load event\n\n            _triggerCallback(_afterLoad, element); // cleanup image object\n\n\n            imageObj.remove(); // remove item from waiting queue and possibly trigger finished event\n\n            _reduceAwaiting();\n          }); // set sources\n          // do it as single 'attr' calls, to be sure 'src' is set after 'srcset'\n\n          var imageSrc = (_isRetinaDisplay && elementRetina ? elementRetina : element.attr(srcAttribute)) || '';\n          imageObj.attr(_sizes, element.attr(sizesAttribute)).attr(_srcset, element.attr(srcsetAttribute)).attr(_src, imageSrc ? imageBase + imageSrc : null); // call after load even on cached image\n\n          imageObj.complete && imageObj.trigger(_load); // jshint ignore : line\n        }\n    }\n    /**\r\n     * check if the given element is inside the current viewport or threshold\r\n     * @access private\r\n     * @param {object} element\r\n     * @return {boolean}\r\n     */\n\n\n    function _isInLoadableArea(element) {\n      var elementBound = element.getBoundingClientRect(),\n          direction = config.scrollDirection,\n          threshold = config.threshold,\n          vertical = // check if element is in loadable area from top\n      _getActualHeight() + threshold > elementBound.top && // check if element is even in loadable are from bottom\n      -threshold < elementBound.bottom,\n          horizontal = // check if element is in loadable area from left\n      _getActualWidth() + threshold > elementBound.left && // check if element is even in loadable area from right\n      -threshold < elementBound.right;\n\n      if (direction === 'vertical') {\n        return vertical;\n      } else if (direction === 'horizontal') {\n        return horizontal;\n      }\n\n      return vertical && horizontal;\n    }\n    /**\r\n     * receive the current viewed width of the browser\r\n     * @access private\r\n     * @return {number}\r\n     */\n\n\n    function _getActualWidth() {\n      return _actualWidth >= 0 ? _actualWidth : _actualWidth = $(window).width();\n    }\n    /**\r\n     * receive the current viewed height of the browser\r\n     * @access private\r\n     * @return {number}\r\n     */\n\n\n    function _getActualHeight() {\n      return _actualHeight >= 0 ? _actualHeight : _actualHeight = $(window).height();\n    }\n    /**\r\n     * get lowercase tag name of an element\r\n     * @access private\r\n     * @param {object} element\r\n     * @returns {string}\r\n     */\n\n\n    function _getElementTagName(element) {\n      return element.tagName.toLowerCase();\n    }\n    /**\r\n     * prepend image base to all srcset entries\r\n     * @access private\r\n     * @param {string} srcset\r\n     * @param {string} imageBase\r\n     * @returns {string}\r\n     */\n\n\n    function _getCorrectedSrcSet(srcset, imageBase) {\n      if (imageBase) {\n        // trim, remove unnecessary spaces and split entries\n        var entries = srcset.split(',');\n        srcset = '';\n\n        for (var i = 0, l = entries.length; i < l; i++) {\n          srcset += imageBase + entries[i].trim() + (i !== l - 1 ? ',' : '');\n        }\n      }\n\n      return srcset;\n    }\n    /**\r\n     * helper function to throttle down event triggering\r\n     * @access private\r\n     * @param {number} delay\r\n     * @param {function} callback\r\n     * @return {function}\r\n     */\n\n\n    function _throttle(delay, callback) {\n      var timeout,\n          lastExecute = 0;\n      return function (event, ignoreThrottle) {\n        var elapsed = +new Date() - lastExecute;\n\n        function run() {\n          lastExecute = +new Date(); // noinspection JSUnresolvedFunction\n\n          callback.call(instance, event);\n        }\n\n        timeout && clearTimeout(timeout); // jshint ignore : line\n\n        if (elapsed > delay || !config.enableThrottle || ignoreThrottle) {\n          run();\n        } else {\n          timeout = setTimeout(run, delay - elapsed);\n        }\n      };\n    }\n    /**\r\n     * reduce count of awaiting elements to 'afterLoad' event and fire 'onFinishedAll' if reached zero\r\n     * @access private\r\n     * @return void\r\n     */\n\n\n    function _reduceAwaiting() {\n      --_awaitingAfterLoad; // if no items were left trigger finished event\n\n      if (!items.length && !_awaitingAfterLoad) {\n        _triggerCallback('onFinishedAll');\n      }\n    }\n    /**\r\n     * single implementation to handle callbacks, pass element and set 'this' to current instance\r\n     * @access private\r\n     * @param {string|function} callback\r\n     * @param {object} [element]\r\n     * @param {*} [args]\r\n     * @return {boolean}\r\n     */\n\n\n    function _triggerCallback(callback, element, args) {\n      if (callback = config[callback]) {\n        // jQuery's internal '$(arguments).slice(1)' are causing problems at least on old iPads\n        // below is shorthand of 'Array.prototype.slice.call(arguments, 1)'\n        callback.apply(instance, [].slice.call(arguments, 1));\n        return true;\n      }\n\n      return false;\n    } // if event driven or window is already loaded don't wait for page loading\n\n\n    if (config.bind === 'event' || windowLoaded) {\n      _initialize();\n    } // otherwise load initial items and start lazy after page load\n    else {\n        // noinspection JSUnresolvedVariable\n        $(window).on(_load + '.' + namespace, _initialize);\n      }\n  }\n  /**\r\n   * lazy plugin class constructor\r\n   * @constructor\r\n   * @access private\r\n   * @param {object} elements\r\n   * @param {object} settings\r\n   * @return {object|LazyPlugin}\r\n   */\n\n\n  function LazyPlugin(elements, settings) {\n    /**\r\n     * this lazy plugin instance\r\n     * @access private\r\n     * @type {object|LazyPlugin|LazyPlugin.prototype}\r\n     */\n    var _instance = this,\n\n    /**\r\n     * this lazy plugin instance configuration\r\n     * @access private\r\n     * @type {object}\r\n     */\n    _config = $.extend({}, _instance.config, settings),\n\n    /**\r\n     * instance generated event executed on container scroll or resize\r\n     * packed in an object to be referenceable and short named because properties will not be minified\r\n     * @access private\r\n     * @type {object}\r\n     */\n    _events = {},\n\n    /**\r\n     * unique namespace for instance related events\r\n     * @access private\r\n     * @type {string}\r\n     */\n    _namespace = _config.name + '-' + ++lazyInstanceId; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * wrapper to get or set an entry from plugin instance configuration\r\n     * much smaller on minify as direct access\r\n     * @access public\r\n     * @type {function}\r\n     * @param {string} entryName\r\n     * @param {*} [value]\r\n     * @return {LazyPlugin|*}\r\n     */\n\n\n    _instance.config = function (entryName, value) {\n      if (value === undefined) {\n        return _config[entryName];\n      }\n\n      _config[entryName] = value;\n      return _instance;\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * add additional items to current instance\r\n     * @access public\r\n     * @param {Array|object|string} items\r\n     * @return {LazyPlugin}\r\n     */\n\n\n    _instance.addItems = function (items) {\n      _events.a && _events.a($.type(items) === 'string' ? $(items) : items); // jshint ignore : line\n\n      return _instance;\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * get all left items of this instance\r\n     * @access public\r\n     * @returns {object}\r\n     */\n\n\n    _instance.getItems = function () {\n      return _events.g ? _events.g() : {};\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * force lazy to load all items in loadable area right now\r\n     * by default without throttle\r\n     * @access public\r\n     * @type {function}\r\n     * @param {boolean} [useThrottle]\r\n     * @return {LazyPlugin}\r\n     */\n\n\n    _instance.update = function (useThrottle) {\n      _events.e && _events.e({}, !useThrottle); // jshint ignore : line\n\n      return _instance;\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * force element(s) to load directly, ignoring the viewport\r\n     * @access public\r\n     * @param {Array|object|string} items\r\n     * @return {LazyPlugin}\r\n     */\n\n\n    _instance.force = function (items) {\n      _events.f && _events.f($.type(items) === 'string' ? $(items) : items); // jshint ignore : line\n\n      return _instance;\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * force lazy to load all available items right now\r\n     * this call ignores throttling\r\n     * @access public\r\n     * @type {function}\r\n     * @return {LazyPlugin}\r\n     */\n\n\n    _instance.loadAll = function () {\n      _events.e && _events.e({\n        all: true\n      }, true); // jshint ignore : line\n\n      return _instance;\n    }; // noinspection JSUndefinedPropertyAssignment\n\n    /**\r\n     * destroy this plugin instance\r\n     * @access public\r\n     * @type {function}\r\n     * @return undefined\r\n     */\n\n\n    _instance.destroy = function () {\n      // unbind instance generated events\n      // noinspection JSUnresolvedFunction, JSUnresolvedVariable\n      $(_config.appendScroll).off('.' + _namespace, _events.e); // noinspection JSUnresolvedVariable\n\n      $(window).off('.' + _namespace); // clear events\n\n      _events = {};\n      return undefined;\n    }; // start using lazy and return all elements to be chainable or instance for further use\n    // noinspection JSUnresolvedVariable\n\n\n    _executeLazy(_instance, _config, elements, _events, _namespace);\n\n    return _config.chainable ? elements : _instance;\n  }\n  /**\r\n   * settings and configuration data\r\n   * @access public\r\n   * @type {object|*}\r\n   */\n\n\n  LazyPlugin.prototype.config = {\n    // general\n    name: 'lazy',\n    chainable: true,\n    autoDestroy: true,\n    bind: 'load',\n    threshold: 500,\n    visibleOnly: false,\n    appendScroll: window,\n    scrollDirection: 'both',\n    imageBase: null,\n    defaultImage: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',\n    placeholder: null,\n    delay: -1,\n    combined: false,\n    // attributes\n    attribute: 'data-src',\n    srcsetAttribute: 'data-srcset',\n    sizesAttribute: 'data-sizes',\n    retinaAttribute: 'data-retina',\n    loaderAttribute: 'data-loader',\n    imageBaseAttribute: 'data-imagebase',\n    removeAttribute: true,\n    handledName: 'handled',\n    loadedName: 'loaded',\n    // effect\n    effect: 'show',\n    effectTime: 0,\n    // throttle\n    enableThrottle: true,\n    throttle: 250,\n    // callbacks\n    beforeLoad: undefined,\n    afterLoad: undefined,\n    onError: undefined,\n    onFinishedAll: undefined\n  }; // register window load event globally to prevent not loading elements\n  // since jQuery 3.X ready state is fully async and may be executed after 'load' \n\n  $(window).on('load', function () {\n    windowLoaded = true;\n  });\n})(window);"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}